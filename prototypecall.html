<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>Function.prototype.apply</title>
</head>
<body>
<script>
    function Product(name, price) {
        this.name = name;
        this.price = price;

        if (price < 0) {
            throw RangeError('Cannot create product ' +
            this.name + ' with a negative price');
        }
        console.log(this);
        return this;
    }

    function Food(name, price) {
        Product.call(this, name, price);
        this.category = 'food';
    }

    Food.prototype = Object.create(Product.prototype);
    Food.prototype.constructor = Food; // Reset the constructor from Product to Food

    function Toy(name, price) {
        Product.call(this, name, price);
        this.category = 'toy';
    }

    Toy.prototype = Object.create(Product.prototype);
    Toy.prototype.constructor = Toy; // Reset the constructor from Product to Toy

    var cheese = new Food('feta', 5);
    var fun = new Toy('robot', 40);



    function  Person(name,age,love){
        this.name=name;
        this.age=age;
        this.love=love;
        this.say=function say(){
            console.log("姓名："+this.name+"\t年龄"+this.age+'\t爱情'+this.love);
        }
    }
    //call方式此处的this是指将被用作当前对象的对象
    function student(name,age,love){
        Person.call(this,name,age,love);
    }

    //apply方式
    function teacher(name,age,love){
        Person.apply(this,[name,age,love]);
    }
    var per=new Person("武凤楼",25,"魏荧屏"); //输出：“武凤楼”
    per.say();
    var stu=new student("曹玉",18,'徐宝婷');//输出：“曹玉”
    stu.say();
    var tea=new teacher("秦杰",16,'吴广东');//输出：“秦杰”
    tea.say();
    var arr1=[1,3,4];
    var arr2=[3,4,5];
    var newArr = Array.prototype.push.apply(arr1,arr2);
    console.log(arr1);
    console.log(Math.max.apply(Math,arr1));
    console.log(Math.min.apply(Math,arr1));
//我们可以发现这个map函数的实现功能和函数sort是一样的，我们自定义一个方法，但是自己不去调用他，只是把它放入另一个函数中当做参数传入，这样就行成了所谓的回调函数
//利用map函数实现为元素组中的每个元素都拼接一段字符串
    function a (str) {
        return str+'32';
    }
    var xbt = [1,2,3,4,5];
    console.log(xbt.map(a));
//利用map函数求解元数组中的每个元素的立方跟
    function b (str) {
        return  Math.cbrt(str);
    }
    var xbt1 = [1,8,64];
    console.log(xbt1.map(b));
    //利用map函数实现对一个字符串中的每个字符求解对应的ASC码
    function c (str) {
        return  str.charCodeAt();
    }
    var xbt2 = ['徐','宝','婷'];
    console.log(xbt2.map(c));

    function d(str) {
        return parseInt(str)
    }
    var xbt3 = ['1.1','2.2','3.3','4.4','5.5'];
    console.log(xbt3.map(d));

    // 通常使用parseInt时,只需要传递一个参数.但实际上,parseInt可以有两个参数.第二个参数是进制数.可以通过语句"alert(parseInt.length)===2"来验证.
    // map方法在调用callback函数时,会给它传递三个参数:当前正在遍历的元素, 元素索引, 原数组本身.
    // 第三个参数parseInt会忽视, 但第二个参数不会,也就是说,parseInt把传过来的索引值当成进制数来使用.从而返回了NaN.
    console.log(xbt3.map(parseInt))
</script>
</body>
</html>